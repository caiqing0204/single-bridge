### 创建型

1. #### 简单工厂模式

   1. 如果类太多，那么提供一个

      每次创建还要找到的对应的类

      其他人都不用再关注创建这些对象到底依赖于哪个基类

   2. 一个对象有时可以代替多个类，通过创建一个新对象，然后包装（if）增强其属性和功能

2. #### 工厂方法模式

   1. 安全模式类

      防止用户直接调用Person() 而不用new的形式调用

      在内部判断this instanceof  Person   

      这个在class中是不需要判断的，因为class 如果不使用new 调用会报错

3. #### 抽象工厂模式

   1. 抽象父类

      改类不用于实例化，是一个类簇，制定类的结构，制定一个共有的东西

      父类方法通过throw new Error 实现子类实例化后，如果不覆写父类的方法，调用时会报错

4. #### 建造者模式

   1. 用于创建一个更复合的对象

      对象的属性是另一个类的实例，需要了解整个对象创建的过程

5. #### 原型模式

   1. js中的继承是靠原型链实现的
   2. 对于父类，简单而又差异化的属性放到构造函数中，消耗资源的方法放在基类的原型中
   3. 无论是基类还是子类都可以方便的对方法(原型)进行拓展，实例都可以接受到

6. #### 单例模式

   1. 一个只允许实例化一次的类，节省系统资源
   2. 命名空间 jquery
   3. 创建无法修改的静态变量 (闭包)
   4. 惰性单例，延迟创建，用到的时候在创建，也是用闭包，调用方法时，判断闭包内是否有对象，没有就创建

### 结构型

1. #### 外观模式

   1. 为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口，使得对子系统接口的访问更容易。
   2. 会用于对低层结构兼容性做统一的封装：addEvent

2. #### 适配器模式

   1. 解决使类(对象)之间的接口的不兼容问题
   2. promiseify
   3. 适配异类框架，重写私有框架A，将低层实现使用jquery替换
   4. 参数适配，默认参数
   5. 数据适配，写处理数据函数，标注扁平化展示

3. #### 代理模式

   1. 一个对象不能直接引用另外一个对象，通过代理对象访问
   2. img之类的标签通过src属性可以向其他域下的服务器发送请求，不过这类请求时get请求，并且是单向的，数据量过大时会被截断
   3. json原理，告诉服务器端回调函数的名字，让服务器端返回的js文件中，执行这个函数，并且把response当做参数传入该函数

4. #### 装饰器模式

   1. 不改变原有对象的基础上，对其进行包装拓展
   2. 不需要知道原有方法的实现，在原有基础上添砖加瓦

5. #### 桥接模式

   1. 将元素的事件与业务逻辑解耦，一个方法只做一件事
   2. 将相同的逻辑做抽象提取处理
   3. 多元化对象，一个人单元是有一个说话单元和一个吃饭单元共同组合在一起的

6. #### 组合模式(难)

   1. P100   新闻类  和表单类   new 实例       init  add   getElement
   2. 唯一要求：接口的统一
   3. 面向对象  语义化    
   4. 组合对象类通过继承同一个父类使其具有统一的方法，
   5. 组合模式能够提供一个清晰的组成结构

7. ####  享元模式

   1. 享元对象：分页模块   共享div
   2. 享元动作：继承原型对象，共享共有方法

### 行为型

1. #### 模板方法模式

   1. 照猫画虎，提示框由简到繁
   2. init  panel  bindEvent    在最基本的提示框类进行修改就可以在所有的提示框中实现
   3. 核心在于重用，将核心方法封装在基类中，让子类继承基类的方法

2. #### 观察者模式

   1. 同一个模块的内容理应放在一起
   2. 最主要的作用是解决类或对象之间耦合，解耦两个相互依赖的对象
   3. 大型项目的模块化开发中，一个工程师很难做到熟知项目中的每个模块

3. #### 状态模式(歧义)

   1. 当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象
   2. states 对象，减少if 分支，对于状态模式，主要目的就是将条件判断的不同结果转化为状态对象的内部状态，作为状态对象内部的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象，这样当我们需要增删改查某种状态方法时就会很容易
   3. states   show    ;   超级玛丽的动作状态对象，跳，打，射击changestate  goes

4. #### 策略模式

   1. 定义一组算法封装起来，使其相互之间可以替换，具有独立性，不随客户端变化而变化
   2. 不需要状态管理，状态之间没有依赖关系，在外部看不到算法的具体实现
   3. 算法脱离模块逻辑独立管理
   4. 优点：复用率高，与继承相比，解耦算法与算法的使用者，优化分支的一种方式
   5. strategy

5. #### 职责链模式

   1. 分解请求，每件事独立出一个模块去处理，getData  dealData  sendData  createSug

6. #### 命令模式(！！！)

   1. 

7. #### 访问者模式

8. #### 中介者模式

   1. 房屋中介发布消息  即发布订阅模式

9. #### 备忘录模式

   1. 对请求来的数据做缓存(不常变的)

10. ##### 迭代器模式

11. #### 解释器模式

### 技巧型

1. #### 链式模式

   1. 在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用

2. #### 委托模式

   1. 事件委托：减少事件监听器的绑定，节省内存，借用事件流，在事件冒泡阶段，通过判断事件源(子元素的特性，如元素名称，class，id)来执行某一业务逻辑，这样也可以未将来动态添加的元素绑定事件，同时防止内存外泄，如在老版本ie中  btn绑定了一个事件，点击后使用innerhtml方式清除自身，但是onclick事件仍然没有清除，需要在清空自己钱手动清除，通过事件委托，委托给父元素做这件事，就不用考虑这种情况
   2. 多个对象接收并处理同一个请求，他们将请求委托给另一个对象统一处理，在其他设计模式也有应用，如状态模式状态对象，策略模式策略对象，命令模式命令对象

3. 213

4. 123